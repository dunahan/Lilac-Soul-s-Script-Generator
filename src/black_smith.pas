{
Copyright 2006 Carsten Hjorthøj (Lilac Soul)

The Script Generator is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

The Script Generator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}
{
Modified by: The Krit, March 2011
* Adapted from Delphi to Lazarus/fpc.
* Some of this was trimmed when I converted the form to being actually modal from
    simulated modal.
* Cleanup of the generated scripts (better style and more robust).
* Added ability to specify a quantity of reagents.
}

{$MODE Delphi}
{$LONGSTRINGS OFF}
{$WRITEABLECONST OFF}


unit black_smith;


interface

uses
  {Windows,} {Messages,} SysUtils, Classes, {Graphics, Controls,} Forms, {Dialogs,}
  StdCtrls, Buttons, Spin, ExtCtrls,
  LResources;

type

  { Tblacksmith }

  Tblacksmith = class(TForm)
    // Form elements
      BitBtn3: TBitBtn;
      BitBtn8: TBitBtn;
      ComboSpell: TComboBox;
      EditReagentName: TEdit;
      GroupRequirements: TGroupBox;
      itemtag: TListBox;
      Label2: TLabel;
      LabelReagent: TLabel;
      LabelGold: TLabel;
      LabelCreateName: TLabel;
      LabelReagentName: TLabel;
      LabelReagentAmount: TLabel;
      LabelSpell: TLabel;
      LabelToCreate: TLabel;
      LabelWhen: TLabel;
      LabelVFX: TLabel;
      PanelSpell: TPanel;
    resref: TEdit;
    Label1: TLabel;
    EditCreateName: TEdit;
    SpinEdit1: TSpinEdit;
    SpinReagentAmount: TSpinEdit;
    tag: TEdit;
    BitBtn1: TBitBtn;
    BitBtn2: TBitBtn;
    BitBtn4: TBitBtn;
    ComboBox1: TComboBox;
    RadioGroup1: TRadioGroup;
    BitBtn6: TBitBtn;
    BitBtn7: TBitBtn;
    TextReagentList: TStaticText;
    // Event handlers
    procedure FormCreate(Sender: TObject);
    procedure itemtagDblClick(Sender: TObject);
    procedure RadioGroup1Click(Sender: TObject);
    procedure tagChange(Sender: TObject);
    procedure ToggleNext(Sender: TObject);
    procedure BitBtn1Click(Sender: TObject);
    procedure BitBtn2Click(Sender: TObject);
    procedure BitBtn3Click(Sender: TObject);
    procedure BitBtn4Click(Sender: TObject);
    procedure BitBtn6Click(Sender: TObject);
    procedure BitBtn7Click(Sender: TObject);
    procedure BitBtn8Click(Sender: TObject);

  private
    // Helper methods.
    procedure ChangeItem();
    function  MakePrettyReagent(const sTag, sName: shortstring; iAmount: byte) : shortstring;
    procedure SaveCurrentItem();
    function  WriteLocalVars(bUsesSpells: boolean) : integer;
    procedure WriteConfig(bCreatureHolder: boolean);

  public
    // Communication from other units.
    class procedure ResetSmith();
    class function  LoadExistingScript(the_script: TStrings) : boolean;
  end;


{var
  blacksmith: Tblacksmith;
}

// -----------------------------------------------------------------------------

implementation


uses
    start, smith_when, nwn, palettetool,
    constants;


type
    itemrecord = record
        resref:  shortstring;
        name:    shortstring;
        spell:   smallint;
        vfx:     smallint;
        gold:    longint;
        tags:    array of shortstring;
        names:   array of shortstring;
        amounts: array of byte;
    end;


var
    CurrentItem: integer;
    Items:       array of itemrecord;
    script_type: integer;
    // Script types:
    //  0: OnSpellCastAt
    //  1: OnDisturbed
    //  2: OnClose
    //  3: In a conversation}


const
    // The basic contents of a blacksmith script.
    // First, some special lines in ScriptPart1:
    HEADER_MAX   = 3; // The last line used to identify blacksmith scripts.
    VERSION_LINE = 2; // The line (used to identify blacksmith scripts) that has the program version appended.
    BSTYPE_LINE  = 1; // Append the script type code to this line.
    PUTTHIS_LINE = 7; // Append the event name (plus a period) to this line.
    RECIPE_LINE  = 15;// Append the number of recipes (plus a semicolon) to this line.
    // These arrays may be assumed to have zero-based indices, so keep them zero-based.
    ScriptPart1: array[0..22] of pchar =
          ( '/*  BLACKSMITH SCRIPT, format 1.0',
            ' *  Smith type: ', // 0-3                                                      // (line 1)
            ' *  Script generated by LS Script Generator, v.'+ThisVersion,                  // (line 2)
            ' *',
            ' *  For download info, please visit:',
            ' *  http://nwvault.ign.com/View.php?view=Other.Detail&id='+VaultID,
            ' */',
            '// Put this ', // OnSpellCastAt/OnDisturbed/OnClose/under "Actions Taken"      // (line 7)
            '// Note that this will only create one item, even if there are enough ingredients for multiple recipes.',
            '',
            '',
            '#include "x0_inc_skills"',
            '',
            '',
            '// The number of combinations this script accepts for item creation.',
            'const int NUM_RECIPES = ',                                                     // (line 15)
            '',
            '',
            '// Initializes the local variables that define what can be created and how to',
            '// create them.',
            'void SetRecipeLocals(object oVarHolder);',
            'void SetRecipeLocals(object oVarHolder)',
            '{' );
                // Setting of the local variables happens here.
    ScriptPart2: array[0..7] of pchar =
          ( '}',
            '',
            '',
            '// -----------------------------------------------------------------------------',
            '',
            '',
            'void main()',
            '{' );
                // Definitions of oItemHolder, oVarHolder, and nAvailableGold go here.
    ScriptPart3: array[0..16] of pchar =
              ( '// Make sure the recipes are initialized.',
                'if ( !GetLocalInt(oVarHolder, "LS_SMITH_variables_set") )',
                '{',
                '    SetRecipeLocals(oVarHolder);',
                '    SetLocalInt(oVarHolder, "LS_SMITH_variables_set", TRUE);',
                '}',
                '',
                '',
                '// Variables set inside the following loop.',
                'int nNumIngredients, nIngredient, nGold;',
                'string sVarPrefix;',
                '',
                '// Find a matching recipe.',
                'int bIsMatch = FALSE;',
                'int nRecipe = 0;',
                'while ( nRecipe++ < NUM_RECIPES  &&  !bIsMatch )',
                '{' );
    ScriptPart4: array[0..4] of pchar =
                  ( 'sVarPrefix = "LS_SMITH_" + IntToString(nRecipe) + "_";',
                    '',
                    '// Gold requirement.',
                    'nGold = GetLocalInt(oVarHolder, sVarPrefix + "gold");',
                    'bIsMatch = nAvailableGold >= nGold;' );
    ScriptPart5_0: array[0..2] of pchar = // Only used for type 0 scripts.
                  ( '// Spell requirement.',
                    'if ( bIsMatch )',
                    '    bIsMatch =  GetLastSpell() == GetLocalInt(oVarHolder, sVarPrefix + "spell");' );
    ScriptPart6: array[0..14] of pchar =
                  ( '// Item requirements.',
                    'nNumIngredients = GetLocalInt(oVarHolder, sVarPrefix + "ingredient_count");',
                    'nIngredient = 0;',
                    'while ( bIsMatch  &&  nIngredient++ < nNumIngredients )',
                    '    // OK to continue if we have enough of the specified item.',
                    '    // (This function was written for trap components, but it works for this, too.)',
                    '    bIsMatch = skillCTRAPGetHasComponent(',
                    '                    GetLocalString(oVarHolder, sVarPrefix + "ingredient" + IntToString(nIngredient)),',
                    '                    oItemHolder,',
                    '                    GetLocalInt(oVarHolder, sVarPrefix + "quantity" + IntToString(nIngredient)));',
                    '',
                    '',
                    '// Done checking. Can we go ahead and create?',
                    'if ( bIsMatch )',
                    '{' );
    ScriptPart7: array[0..2] of pchar = // Not used for type 3 scripts.
                      ( '// Gold cost:',
                        'if ( nGold > 0 )',
                        '    DestroyNumItems(oItemHolder, "NW_IT_GOLD001", nGold);' );
    ScriptPart7_3: array[0..2] of pchar = // Only used for type 3 scripts.
                      ( '// Gold cost:',
                        'if ( nGold > 0 )',
                        '    TakeGoldFromCreature(nGold, oItemHolder, TRUE);' );
    ScriptPart8: array[0..11] of pchar =
                      ( '// Remove the ingredients.',
                        'for ( nIngredient = 1; nIngredient <= nNumIngredients; nIngredient++ )',
                        '    DestroyNumItems(oItemHolder,',
                        '                    GetLocalString(oVarHolder, sVarPrefix + "ingredient" + IntToString(nIngredient)),',
                        '                    GetLocalInt(oVarHolder, sVarPrefix + "quantity" + IntToString(nIngredient)));',
                        '',
                        '// Now create the item.',
                        'CreateItemOnObject(GetLocalString(oVarHolder, sVarPrefix + "ResRef"), oItemHolder);',
                        '// Add a spiffy visual effect?',
                        'int nVFX = GetLocalInt(oVarHolder, sVarPrefix + "vfx");',
                        'if ( nVFX != VFX_NONE )',
                        '    ApplyEffectToObject(DURATION_TYPE_INSTANT, EffectVisualEffect(nVFX), oItemHolder);' );
    ScriptPart9: array[0..0] of pchar =
                  ( '}' );
    ScriptPart10: array[0..0] of pchar =
              ( '}//while ( nRecipe )' );
    // ScriptEnding has to match what Tlilac expects the end of the main() function
    // to look like.
    ScriptEnding: array[0..0] of pchar =
          ( '}' );


const
    // Some strings used to define recipes. Used for both writing and reading scripts.
    s_NameComment = '    // Recipe for creating ';
    s_SetString = '    SetLocalString';
    s_SetInt    = '    SetLocalInt   '; // Same length as s_SetString. Saves some processing complications.
    s_SetParams = '(oVarHolder, "LS_SMITH_';


// -----------------------------------------------------------------------------


procedure Tblacksmith.FormCreate(Sender: TObject);
begin
    // Fill some combo boxes.
    LoadConstants(ComboSpell.Items, SPELL);
    LoadConstants(ComboBox1.Items, VFX_IMPACT);
    ComboBox1.ItemIndex := 0;

    // Restore the current state.
    RadioGroup1.ItemIndex := script_type;
    RadioGroup1Click(RadioGroup1);
    ChangeItem();
end;


// Deletes reagents from the list when double-clicked.
procedure Tblacksmith.itemtagDblClick(Sender: TObject);
var
    iReagent: integer;
begin
    iReagent := itemtag.itemindex;
    if iReagent < 0 then
        exit;

    // Remove the selected item from the displayed list.
    itemtag.items.delete(iReagent);

    // Remove the selected item from our internal list.
    while iReagent < High(Items[CurrentItem].tags) do begin
        // Shift the next record down.
        Items[CurrentItem].tags[iReagent]    := Items[CurrentItem].tags[iReagent+1];
        Items[CurrentItem].names[iReagent]   := Items[CurrentItem].names[iReagent+1];
        Items[CurrentItem].amounts[iReagent] := Items[CurrentItem].amounts[iReagent+1];
        Inc(iReagent);
    end;
    // At this point, iReagent is Length(Items[CurrentItem].tags) - 1.
    SetLength(Items[CurrentItem].tags, iReagent);
    SetLength(Items[CurrentItem].names, iReagent);
    SetLength(Items[CurrentItem].amounts, iReagent);

    // Update buttons.
    ToggleNext(Sender);
end;


// Handles changes to the script type.
procedure Tblacksmith.RadioGroup1Click(Sender: TObject);
begin
    // Remember this type for when/if the user closes this form then comes back to it.
    script_type := RadioGroup1.itemindex;

    // Spells are choices exactly when the script will go OnSpellCastAt.
    PanelSpell.enabled :=  script_type = 0;

    // Update buttons.
    ToggleNext(Sender);
end;


// Controls the enabled state of the "Add to list" button.
procedure Tblacksmith.tagChange(Sender: TObject);
begin
    bitbtn3.enabled := tag.text <> '';
end;


// Handles the enabled state of the "Next" button.
procedure Tblacksmith.ToggleNext(Sender: TObject);
var
    bEnable: boolean;
begin
    // Always enable the button if the next item has been defined.
    if CurrentItem < High(Items) then
        bEnable := TRUE
    // We need a complete entry -- both reagent(s) and ResRef specified.
    else if (itemtag.items.count = 0)  or  (resref.Text = '') then
        bEnable := FALSE
    // OnSpellCastAt requires a spell.
    else if PanelSpell.Enabled then
        bEnable := ComboSpell.ItemIndex >= 0
    else
        // passed all tests.
        bEnable := TRUE;

    // Update the button.
    bitbtn2.enabled := bEnable;
end;


// Handles clicks of the "Previous" button.
procedure Tblacksmith.BitBtn1Click(Sender: TObject);
begin
    // Save what we have.
    SaveCurrentItem();
    // Go to the previous item.
    Dec(CurrentItem);
    ChangeItem();
end;


// Handles clicks of the "Next" button.
procedure Tblacksmith.BitBtn2Click(Sender: TObject);
begin
    // Save what we have.
    SaveCurrentItem();
    // Go to the next item.
    Inc(CurrentItem);
    ChangeItem();
end;


// Handles clicks of the "Add to list" button.
procedure Tblacksmith.BitBtn3Click(Sender: TObject);
var
    iReagent: integer;
begin
    // Make sure we have a place allocated for this item.
    if CurrentItem > High(Items) then
        SetLength(Items, CurrentItem + 1);

    iReagent := Length(Items[CurrentItem].tags);

    // Allocate space for this reagent.
    SetLength(Items[CurrentItem].tags, iReagent+1);
    SetLength(Items[CurrentItem].names, iReagent+1);
    SetLength(Items[CurrentItem].amounts, iReagent+1);

    // Add this reagent to our internal list.
    Items[CurrentItem].tags[iReagent]    := QuoteSwap(tag.text);
    Items[CurrentItem].names[iReagent]   := EditReagentName.Text;
    Items[CurrentItem].amounts[iReagent] := SpinReagentAmount.Value;

    // Add this reagent to the displayed list.
    itemtag.items.add(MakePrettyReagent(Items[CurrentItem].tags[iReagent],
                                        Items[CurrentItem].names[iReagent],
                                        Items[CurrentItem].amounts[iReagent]));

    // Clear fields.
    tag.text                := '';
    EditreagentName.Text    := '';
    SpinReagentAmount.Value := 1;

    // Update buttons.
    ToggleNext(Sender);
end;


// Handles clicks of the "Script" button.
procedure Tblacksmith.BitBtn4Click(Sender: TObject);
var
    bUsesSpells, bCreatureHolder: boolean;
    iLine: integer;
    iRecipeCount: integer;
begin
    bUsesSpells     := PanelSpell.Enabled;
    bCreatureHolder := radiogroup1.itemindex = 3;

    // Make sure the current entry is recorded.
    SaveCurrentItem();

    // Restart the script window with the header and skeleton for a blacksmith script.
    main.scriptwindow.clear();
    for iLine := 0 to High(ScriptPart1) do
        main.scriptwindow.Append(ScriptPart1[iLine]);

    // Define the local variables that will define our recipe book.
    iRecipeCount := WriteLocalVars(bUsesSpells);

    // Some special lines need additional info.
    with main.scriptwindow.Lines do begin
        Strings[BSTYPE_LINE]  := Strings[BSTYPE_LINE]  + inttostr(radiogroup1.itemindex);
        Strings[RECIPE_LINE]  := Strings[RECIPE_LINE]  + IntToStr(iRecipeCount)+';';

        case radiogroup1.itemindex of
            0: Strings[PUTTHIS_LINE] := Strings[PUTTHIS_LINE] + 'OnSpellCastAt for a placeable.';
            1: Strings[PUTTHIS_LINE] := Strings[PUTTHIS_LINE] + 'OnDisturbed for a placeable.';
            2: Strings[PUTTHIS_LINE] := Strings[PUTTHIS_LINE] + 'OnClose for a placeable.';
            3: Strings[PUTTHIS_LINE] := Strings[PUTTHIS_LINE] + 'under "Actions Taken" in a conversation.';
        end;
    end;

    // Progress to the main function.
    for iLine := 0 to High(ScriptPart2) do
        main.scriptwindow.Append(ScriptPart2[iLine]);
    // And end the main function so that Tlilac can be used (for indentation).
    for iLine := 0 to High(ScriptEnding) do
        main.scriptwindow.Append(ScriptEnding[iLine]);

    // Define who/what is involved in this script.
    WriteConfig(bCreatureHolder);

    // The rest of the pieces of the script:
    Tlilac.AddLines(ScriptPart3);       // (Ends by starting a new indentation level.)
    Tlilac.AddLines(ScriptPart4);
    if bUsesSpells then
        Tlilac.AddLines(ScriptPart5_0); // The check for matching a spell.
    Tlilac.AddLines(ScriptPart6);       // (Ends by starting a new indentation level.)
    if bCreatureHolder then
        Tlilac.AddLines(ScriptPart7_3)  // Takes gold from a creature.
    else
        Tlilac.AddLines(ScriptPart7);   // Takes gold items from inventory.
    Tlilac.AddLines(ScriptPart8);
    Tlilac.AddLines(ScriptPart9);       // (Ends an indentation level.)
    Tlilac.AddLines(ScriptPart10);      // (Ends an indentation level.)
end;


// Handles clicks of the "What's this?" button.
procedure Tblacksmith.BitBtn6Click(Sender: TObject);
begin
    main.ShowPopup(Twhentofire);
end;


// Handles clicks of the "Palette" button for item ResRefs.
procedure Tblacksmith.BitBtn7Click(Sender: TObject);
begin
    // Call up the palette window, items by default.
    TPaletteWindow.Load(ResRef, EditCreateName, SEARCH_ITEMS, TRUE);
end;


// Handles clicks of the "Palette" button for item tags.
procedure Tblacksmith.BitBtn8Click(Sender: TObject);
begin
    // Call up the palette window, items by default.
    TPaletteWindow.Load(tag, EditReagentName, SEARCH_ITEMS, FALSE);
end;


// -----------------------------------------------------------------------------


procedure Tblacksmith.ChangeItem();
var
   iReagent: integer;
begin
    // Is this one completely new?
    if CurrentItem > High(Items) then begin
        // Clear all info for this item.
        resref.text          := '';
        EditCreateName.Text  := '';
        ComboSpell.itemindex := -1;
        SpinEdit1.Value      := 0;
        itemtag.clear();
        // But keep the VFX since that might get re-used.
    end
    else begin
        // Restore this item's info from the array.
        resref.text          := Items[CurrentItem].resref;
        EditCreateName.Text  := Items[CurrentItem].name;
        ComboSpell.itemindex := Items[CurrentItem].spell;
        combobox1.itemindex  := Items[CurrentItem].vfx;
        SpinEdit1.Value      := Items[CurrentItem].gold;
        // Now reload the list of reagents.
        itemtag.clear();
        for iReagent := 0 to High(Items[currentitem].tags) do
            itemtag.items.add(MakePrettyReagent(Items[CurrentItem].tags[iReagent],
                                                Items[CurrentItem].names[iReagent],
                                                Items[CurrentItem].amounts[iReagent]));
    end;
    // In both cases, we clear out the inputs for new reagents.
    tag.Text                := '';
    EditReagentName.Text    := '';
    SpinReagentAmount.Value := 1;

    // Update the "Prev"/"Next" buttons.
    bitbtn1.enabled := CurrentItem > 0;
    ToggleNext(bitbtn2);
end;


// Converts a reagent's info into a "pretty" string to display to the user.
function Tblacksmith.MakePrettyReagent(const sTag, sName: shortstring; iAmount: byte) : shortstring;
begin
    result := IntToStr(iAmount)+'x '+sTag;
    if sName <> '' then
        result += ' ('+sName+')';
end;


// Saves the currently displayed info to the Items array.
procedure Tblacksmith.SaveCurrentItem();
begin
    // Make sure we have space.
    if CurrentItem > High(Items) then
        SetLength(Items, CurrentItem + 1);

    // Save the form's info to Items[CurrentItem].
    Items[CurrentItem].resref := QuoteSwap(resref.text);
    Items[CurrentItem].name   := EditCreateName.Text;
    Items[CurrentItem].spell  := ComboSpell.itemindex;
    Items[CurrentItem].vfx    := combobox1.itemindex;
    Items[CurrentItem].gold   := spinedit1.value;
    // The reagent list has been kept current as itemtag gets changed.
end;


// Writes to the script window the local variable definitions that define our recipe book.
// Returns the number of recipes written (excludes incomplete entries from _Items_).
function  Tblacksmith.WriteLocalVars(bUsesSpells: boolean) : integer;
var
    WorkingList: array of itemrecord;

    iRecipe, iCopy, iReagent: integer;
    sRecipe:   shortstring;
    sTempLine: shortstring;
begin
    // Make a copy of Items, trimming out those that are incomplete.
    SetLength(WorkingList, Length(Items));
    iCopy := 0;
    for iRecipe := 0 to High(Items) do
        if (Items[iRecipe].resref <> '')  and  (Length(Items[iRecipe].tags) > 0)  and
           ((Items[iRecipe].spell >= 0)  or  not PanelSpell.Enabled) then
        begin
            WorkingList[iCopy] := Items[iRecipe];
            Inc(iCopy);
        end;
    SetLength(WorkingList, iCopy);
    // This is the number we should return.
    result := iCopy;

    // Special case: no recipes.
    if Length(WorkingList) < 1 then begin
        main.scriptwindow.Append('');
        main.scriptwindow.Append('        /****** No items defined for this blacksmith! ******/');
        main.scriptwindow.Append('');
        exit;
    end;

    // Loop though the items that could be created.
    for iRecipe := 0 to High(WorkingList) do begin
        // We'll need the item number as a string.
        sRecipe := inttostr(iRecipe);

        // The basics: name and blueprint.
        sTempLine := s_NameComment;
        if WorkingList[iRecipe].name <> '' then
            sTempLine += WorkingList[iRecipe].name
        else
            sTempLine += WorkingList[iRecipe].resref;
        main.scriptwindow.Append(sTempLine+'.');
        main.scriptwindow.Append(s_SetString + s_SetParams + sRecipe+'_ResRef", "'+
                                 WorkingList[iRecipe].resref+'");');

        // Gold and number of ingredients.
        main.scriptwindow.Append(s_SetInt + s_SetParams + sRecipe+'_gold", '+
                                 IntToStr(WorkingList[iRecipe].gold)+');');
        main.scriptwindow.Append(s_SetInt + s_SetParams + sRecipe+'_ingredient_count", '+
                                 inttostr(Length(WorkingList[iRecipe].tags))+');');

        // The ingredient tags:
        for iReagent := 0 to High(WorkingList[iRecipe].tags) do begin
            sTempLine := s_SetString + s_SetParams + sRecipe+'_ingredient'+inttostr(iReagent)+'", "'+
                         WorkingList[iRecipe].tags[iReagent]+'");';
            if WorkingList[iRecipe].names[iReagent] <> '' then
                sTempLine += ' // '+WorkingList[iRecipe].names[iReagent];
            main.scriptwindow.Append(sTempLine);
        end;
        // The ingredient quantities:
        for iReagent := 0 to High(WorkingList[iRecipe].amounts) do
            main.scriptwindow.Append(s_SetInt + s_SetParams + sRecipe+'_quantity'+inttostr(iReagent)+'", '+
                                     IntToStr(WorkingList[iRecipe].amounts[iReagent])+');');

        // The rest of the info:
        if bUsesSpells then
            main.scriptwindow.Append(s_SetInt + s_SetParams + sRecipe+'_spell", '+
                                     SymConst(SPELL, WorkingList[iRecipe].spell)+');');
        main.scriptwindow.Append(s_SetInt + s_SetParams + sRecipe+'_vfx", '+
                                 SymConst(VFX_IMPACT, WorkingList[iRecipe].vfx)+');');

        // A blank line separating recipes.
        main.scriptwindow.Append('');
    end;//for iRecipe

    // Remove the last blank line.
    main.scriptwindow.Lines.Delete(main.scriptwindow.Lines.Count - 1);
end;


// Sends script variable definition/initialization to the script window (using Tlilac).
procedure Tblacksmith.WriteConfig(bCreatureHolder: boolean);
var
    new_lines: array[0..4] of shortstring;
begin
    // Fairly simple. There is just some variability in who holds the items.
    new_lines[0] := '// Basic configuration:';
    new_lines[1] := 'object oItemHolder = '+BoolToStr(bCreatureHolder, 'GetPCSpeaker()', s_OBJECT_SELF)+';';
    new_lines[2] := 'object oVarHolder  = '+s_OBJECT_SELF+';';
    new_lines[3] := 'int nAvailableGold = GetGold(oItemHolder);';
    new_lines[4] := '';

    Tlilac.AddLines(new_lines);
end;


// -----------------------------------------------------------------------------
// Class methods
// -----------------------------------------------------------------------------


// -----------------------------------------------------------------------------
// Some helper functions that will be used by a class function.
// Private to this unit.
function  LoadNewScript(the_script: TStrings) : boolean;                            forward;
function  LoadScriptType(the_script: TStrings) : integer;                           forward;
function  LoadRecipe(out the_recipe:itemrecord; the_script:TStrings;
                     var iLine: integer; const iLeftSkip, iSpell:integer): boolean; forward;
function  LoadReagentTags(out tags, names:array of shortstring; the_script:TStrings;
                          var iLine: integer; iLeftSkip:integer): boolean;          forward;
function  LoadReagentAmounts(var amounts:array of byte; the_script:TStrings;
                             var iLine: integer; iLeftSkip:integer): boolean;       forward;
function  LoadOldScript(the_script: TStrings) : boolean;                            forward;


// -----------------------------------------------------------------------------


// Resets unit variables when the script window is cleared.
class procedure Tblacksmith.ResetSmith();
begin
    // Initialize variables to emptiness.
    SetLength(Items, 0);
    CurrentItem := 0;
    script_type := 0;
end;


// Sets unit variables to match an existing blacksmith script (the contents of the_script).
// This is only needed when the user provides the script; this unit will remember
// the current script until cleared by ResetSmith().
// Returns TRUE iff the_script was recognized as a valid blacksmith script.
class function  Tblacksmith.LoadExistingScript(the_script: TStrings) : boolean;
begin
    if LoadNewScript(the_script) then
        result := TRUE
    else
        result := LoadOldScript(the_script);
end;


// Sets unit variables to match a blacksmith script generated by this program.
// Returns TRUE iff the_script was recognized as a valid blacksmith script.
// Should only be called by LoadExistingScript().
function  LoadNewScript(the_script: TStrings) : boolean;
var
    iLine, iSpell: integer;
    iRecipeCount, iRecipe: integer;
    iLeftSkip, iPlateau: integer;

    // Temp variables that get transferred to unit globals upon success.
    iType:       integer;
    WorkingList: array of itemrecord;
begin
    // Initialize the return value for aborts.
    result := FALSE;

    // Determine the type of script (also involves verifying the header lines).
    iType := LoadScriptType(the_script);
    if iType < 0 then
        exit;
    // The type determines whether or not there are spells listed for each recipe.
    // Instead of a boolean, though, store this as the number of spells per recipe.
    if iType = 0 then
        iSpell := 1
    else
        iSpell := 0;

    // Try to get the number of recipes.
    if the_script.Count <= RECIPE_LINE then
        exit;
    iRecipeCount := StrToIntDef(ChopBoth(the_script[RECIPE_LINE], Length(ScriptPart1[RECIPE_LINE]), 1), -1);
    if iRecipeCount < 0 then
        exit;

    // The length of "SetLocal" lines up to the data, minus the length of the
    // variable name suffix, assuming a single digit for the recipe number.
    // (Don't forget that string data begins with a quote, not counted by this.)
    iLeftSkip := Length(s_SetString + s_SetParams + '0_", ');
    iPlateau := 10; // The point at which we need another digit.

    // Retrieve the list of recipes.
    SetLength(WorkingList, iRecipeCount);
    iLine := Length(ScriptPart1);
    for iRecipe := 0 to iRecipeCount-1 do begin
        // Update the number of digits?
        if iRecipe = iPlateau then begin
            iLeftSkip += 1;
            iPlateau *= 10;
        end;

        if not LoadRecipe(WorkingList[iRecipe], the_script, iLine, iLeftSkip, iSpell) then
            exit;
    end;

    // All data was successfully extracted, so transfer our temp variables to
    // the unit globals.
    script_type := iType;
    Items := WorkingList;
    CurrentItem := 0;

    // Success!
    result := TRUE;
end;


// Returns the type of blacksmith script contained in the_script.
// Returns -1 if the type could not be determined or if the script's header
// does not match what is expected.
// Should only be called by LoadNewScript().
function  LoadScriptType(the_script: TStrings) : integer;
var
    iLine, iType: integer;
begin
    // Initialize the return value for aborts.
    result := -1;

    // Abort on short data. (Hopefully the compiler optimizes this.)
    if (the_script.Count <= BSTYPE_LINE)  or  (the_script.Count <= VERSION_LINE)  or
       (the_script.Count <= HEADER_MAX) then
        exit;

    // Verify the script header.
    // (This is looking rather inefficient at the moment, but it allows changes
    // to be made to ScriptPart1 without needing to track down this part of the code.)
    for iLine := 0 to HEADER_MAX do
        if (iLine <> BSTYPE_LINE)  and  (iLine <> VERSION_LINE)  and
           (the_script[iLine] <> ScriptPart1[iLine]) then
            exit;
    if not StartsWith(the_script[BSTYPE_LINE], ScriptPart1[BSTYPE_LINE]) then
        exit;
    if not StartsWith(the_script[VERSION_LINE],
                      ChopBoth(ScriptPart1[VERSION_LINE], 0, Length(ThisVersion))) then
        exit;

    // Try to get the script type.
    iType := StrToIntDef(ChopBoth(the_script[BSTYPE_LINE], Length(ScriptPart1[BSTYPE_LINE]), 0), -1);
    if (0 <= iType)  and  (iType <= 3) then
        result := iType;
end;


// Loads a single recipe from the_script, starting at line iLine, into the_recipe.
// iLeftSkip is the current number of characters to ignore at the start of each line.
// iSpell is the number of spell lines to expect (currently must be 0 or 1).
// iLine will be updated.
function  LoadRecipe(out the_recipe:itemrecord; the_script:TStrings;
                     var iLine: integer; const iLeftSkip, iSpell:integer): boolean;
var
    iReagentCount: integer;
begin
    // Initialize the return value for aborts.
    result := FALSE;

    // Abort on short data.
    if the_script.Count <= iLine + 3 then
        exit;

    // Get the ResRef.
    the_recipe.resref := ChopBoth(the_script[iLine+1], iLeftSkip + length('ResRef"'), 3);

    // Get the name, if there is one.
    the_recipe.name := ChopBoth(the_script[iLine], Length(s_NameComment), 1);
    if the_recipe.name = the_recipe.resref then
        the_recipe.name := '';

    // Get the gold and number of reagents.
    the_recipe.gold :=
        StrToIntDef(ChopBoth(the_script[iLine+2], iLeftSkip + length('gold'), 2), -1);
    iReagentCount :=
        StrToIntDef(ChopBoth(the_script[iLine+3], iLeftSkip + length('ingredient_count'), 2), -1);
    if (the_recipe.gold < 0)  or  (iReagentCount < 0) then
        exit;

    // Load the reagent data.
    iLine += 4;
    SetLength(the_recipe.tags, iReagentCount);
    SetLength(the_recipe.names, iReagentCount);
    if not LoadReagentTags(the_recipe.tags, the_recipe.names, the_script, iLine, iLeftSkip) then
        exit;
    SetLength(the_recipe.amounts, iReagentCount);
    if not LoadReagentAmounts(the_recipe.amounts, the_script, iLine, iLeftSkip) then
        exit;

    // Abort on short data.
    if the_script.Count <= iLine + iSpell then
        exit;

    // Get the spell?
    if iSpell = 0 then
        the_recipe.spell := -1
    else
        the_recipe.spell :=
            SymbolToIndex(ChopBoth(the_script[iLine], iLeftSkip + length('spell'), 2), SPELL);

    // Get the visual effect.
    the_recipe.vfx :=
        SymbolToIndex(ChopBoth(the_script[iLine+iSpell], iLeftSkip + length('vfx'), 2), VFX_IMPACT);

    // Update the courrent line number.
    iLine += iSpell + 2; // There is a blank line after the VFX.

    // Success!
    result := TRUE;
end;


// Loads a list of reagents from the_script, starting at line iLine, into the
// provided arrays. The arrays are assumed to have been set to the desired length
// (the same length for both arrays).
// iLeftSkip is the current number of characters to ignore at the start of each line.
// iLine will be updated.
function  LoadReagentTags(out tags, names:array of shortstring; the_script:TStrings;
                          var iLine: integer; iLeftSkip:integer): boolean;
var
    iReagent, iPlateau: integer;
    iSplitPoint: integer;
    sReagent: shortstring;
begin
    // Initialize the return value for aborts.
    result := FALSE;

    // Abort on short data.
    if the_script.Count <= iLine + High(tags) then
        exit;

    // Pad the "left skip" by the ingredient suffix.
    iLeftSkip += length('ingredient0"');
    iPlateau := 10; // The point at which we need another digit.

    // Retrieve the list of reagents.
    for iReagent := 0 to High(tags) do begin
        // Update the number of digits?
        if iReagent = iPlateau then begin
            iLeftSkip += 1;
            iPlateau *= 10;
        end;

        // Trimming down to just the tag is tricky since there *might* be
        // a trailing comment.
        sReagent := ChopBoth(the_script[iLine+iReagent], iLeftSkip, 0);
        iSplitPoint := Pos('"', sReagent);
        if iSplitPoint < 2 then // No trailing quote or the tag was "".
            exit;
        tags[iReagent] := copy(sReagent, 1, iSplitPoint-1);

        // Grab the name if there is one.
        iSplitPoint += Length('); // ');
        if Length(sReagent) > iSplitPoint then
            names[iReagent] := ChopBoth(sReagent, iSplitPoint, 0)
        else
            names[iReagent] := '';
    end;

    // Update the current line number.
    iLine += Length(tags);

    // Success!
    result := TRUE;
end;


// Loads a list of reagent quantities from the_script, starting at line iLine, into
// the provided array. The array is assumed to have been set to the desired length.
// iLeftSkip is the current number of characters to ignore at the start of each line.
// iLine will be updated.
// (amounts is really an "out" parameter, but that caused a segmentation fault.)
function  LoadReagentAmounts(var amounts:array of byte; the_script:TStrings;
                             var iLine: integer; iLeftSkip:integer): boolean;
var
    iReagent, iPlateau: integer;
begin
    // Initialize the return value for aborts.
    result := FALSE;

    // Abort on short data.
    if the_script.Count <= iLine + High(amounts) then
        exit;

    // Pad the "left skip" by the ingredient suffix.
    iLeftSkip += length('quantity0');
    iPlateau := 10; // The point at which we need another digit.

    // Retrieve the list of reagents.
    for iReagent := 0 to High(amounts) do begin
        // Update the number of digits?
        if iReagent = iPlateau then begin
            iLeftSkip += 1;
            iPlateau *= 10;
        end;

        // Try to read the amount.
        amounts[iReagent] :=
            StrToIntDef(ChopBoth(the_script[iLine+iReagent], iLeftSkip, 2), -1);
        if amounts[iReagent] < 1 then
            exit;
    end;

    // Update the current line number.
    iLine += Length(amounts);

    // Success!
    result := TRUE;
end;


// Sets unit variables to match a blacksmith script generated by Script Generator v 2.3.
// Returns TRUE iff the_script was recognized as a valid 2.3 blacksmith script.
// Should only be called by LoadExistingScript().
// The logic for finding a match is what LS had in version 2.3.
// (This is a monster function, but since it is legacy support -- somewhat stable --
//  I think I will not break it up.)
function  LoadOldScript(the_script: TStrings) : boolean;
var
    iLine, iResLength: integer;
    iRecipeCount, iRecipe, iRecipeDigits, iRecipePlateau: integer;
    iReagentCount, iReagent, iReagentDigits, iReagentPlateau, iSkips: integer;
    sReagent: shortstring;
    iGold: integer;

    // Temp variables that get transferred to unit globals upon success.
    iType:       integer;
    WorkingList: array of itemrecord;
begin
    // Initialize the return value for aborts.
    result := FALSE;

    // Abort on short data.
    if the_script.Count <= 8 then
        exit;

    // Verify the script header.
    if the_script[0] <> '/*BLACKSMITH SCRIPT'                           then exit;
    if the_script[1] <> 'Created by'                                    then exit;
    if the_script[2] <> 'Lilac Soul''s NWN Script Generator, v. 2.3'    then exit;
    if the_script[3] <> 'for download info please visit'                then exit;
    if the_script[4] <> 'http://nwvault.ign.com/View.php?view=Other.Detail&id=4683&id=625' then exit;
    if the_script[5] <> '*/'                                            then exit;

    // Try to get the number of recipes and script type.
    if not TryStrToInt(ChopBoth(the_script[7], 8, 1), iRecipeCount)     then exit;
    if not TryStrToInt(copy(the_script[8], 11, 1), iType)               then exit;
    // Safety checks.
    if iRecipeCount < 0 then
        iRecipeCount := 0;
    if (iType > 3)  or (iType < 0) then
        iType := 0;
    // LS did not abort in either of these cases, so I won't either.

    // Retrieve the list of items.
    SetLength(WorkingList, iRecipeCount);
    iRecipeDigits := 1;
    iRecipePlateau := 10; // The point at which we need another digit.
    iLine := 12;
    for iRecipe := 0 to iRecipeCount-1 do begin
        // Abort on short data.
        if the_script.Count <= iLine + 1 then
            exit;

        // Update the number of digits?
        if iRecipe+1 = iRecipePlateau then begin
            iRecipeDigits += 1;
            iRecipePlateau *= 10;
        end;

        // Get the ResRef.
        WorkingList[iRecipe].resref := ChopBoth(the_script[iLine], 36 + iRecipeDigits, 3);
        iResLength := Length(WorkingList[iRecipe].resref);
        iLine += 1;

        // LS did not support names, so that gets set to the default.
        WorkingList[iRecipe].name := '';

        // LS mixed gold in with the reagents. Default gold ot 0 and add to it later.
        WorkingList[iRecipe].gold := 0;

        // Try to get the number of reagents used to make this item.
        if not TryStrToInt(ChopBoth(the_script[iLine], 33 + iResLength, 2), iReagentCount) then
            exit;
        if iReagentCount < 0 then
            iReagentCount := 0;     // Again, LS did not abort for bad data, so handle it gracefully.
        iLine += 1;

        // Abort on short data.
        if the_script.Count <= iLine + iReagentCount + 2 then
            exit;

        // Retrieve the list of reagents.
        SetLength(WorkingList[iRecipe].tags, iReagentCount);
        SetLength(WorkingList[iRecipe].names, iReagentCount);
        SetLength(WorkingList[iRecipe].amounts, iReagentCount);
        iReagentDigits := 1;
        iReagentPlateau := 10; // The point at which we need another digit.
        iSkips := 0;
        for iReagent := 0 to iReagentCount-1 do begin
            // Update the number of digits?
            if iReagent+1 = iReagentPlateau then begin
                iReagentDigits += 1;
                iReagentPlateau *= 10;
            end;

            sReagent := ChopBoth(the_script[iLine+iReagent], 37 + iResLength + iReagentDigits, 3);

            // Check for gold.
            if copy(sReagent, 1, 8) = '  gold  ' then begin
                // This reagent represents gold. Suppress it from reagents and
                // add it to the required gold.
                Inc(iSkips);
                if TryStrToInt(ChopBoth(sReagent, 8, 0), iGold) then
                    WorkingList[iRecipe].gold += iGold;
                // Nothing special if the try fails, as LS did not validate this number here.
            end
            else begin
                WorkingList[iRecipe].tags[iReagent-iSkips] := sReagent;
                // LS did not support names or quantities, so those are set to default values.
                WorkingList[iRecipe].names[iReagent-iSkips]   := '';
                WorkingList[iRecipe].amounts[iReagent-iSkips] := 1;
            end;
        end;
        if iSkips > 0 then begin
            // We have extra array entries.
            SetLength(WorkingList[iRecipe].tags, iReagentCount - iSkips);
            SetLength(WorkingList[iRecipe].names, iReagentCount - iSkips);
            SetLength(WorkingList[iRecipe].amounts, iReagentCount - iSkips);
        end;
        iLine += iReagentCount;

        // Get the spell and VFX.
        WorkingList[iRecipe].spell :=
            SymbolToIndex(ChopBoth(the_script[iLine], 33 + iResLength, 2), SPELL);
        WorkingList[iRecipe].vfx :=
            SymbolToIndex(ChopBoth(the_script[iLine+1], 33 + iResLength, 2), VFX_IMPACT);
        iLine += 3; // There is a blank line after the VFX.
    end;//for iRecipe

    // All data was successfully extracted, so transfer our temp variables to
    // the unit globals.
    script_type := iType;
    Items := WorkingList;
    CurrentItem := 0;

    // Success!
    result := TRUE;
end;


initialization
  {$i black_smith.lrs}
end.

